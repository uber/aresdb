// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import io "io"
import mock "github.com/stretchr/testify/mock"
import utils "github.com/uber/aresdb/utils"

// DiskStore is an autogenerated mock type for the DiskStore type
type DiskStore struct {
	mock.Mock
}

// DeleteBatchVersions provides a mock function with given fields: table, shard, batchID, batchVersion, seqNum
func (_m *DiskStore) DeleteBatchVersions(table string, shard int, batchID int, batchVersion uint32, seqNum uint32) error {
	ret := _m.Called(table, shard, batchID, batchVersion, seqNum)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int, int, uint32, uint32) error); ok {
		r0 = rf(table, shard, batchID, batchVersion, seqNum)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBatches provides a mock function with given fields: table, shard, batchIDStart, batchIDEnd
func (_m *DiskStore) DeleteBatches(table string, shard int, batchIDStart int, batchIDEnd int) (int, error) {
	ret := _m.Called(table, shard, batchIDStart, batchIDEnd)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, int, int, int) int); ok {
		r0 = rf(table, shard, batchIDStart, batchIDEnd)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int, int) error); ok {
		r1 = rf(table, shard, batchIDStart, batchIDEnd)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteColumn provides a mock function with given fields: table, column, shard
func (_m *DiskStore) DeleteColumn(table string, column int, shard int) error {
	ret := _m.Called(table, column, shard)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int, int) error); ok {
		r0 = rf(table, column, shard)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteLogFile provides a mock function with given fields: table, shard, creationTime
func (_m *DiskStore) DeleteLogFile(table string, shard int, creationTime int64) error {
	ret := _m.Called(table, shard, creationTime)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int, int64) error); ok {
		r0 = rf(table, shard, creationTime)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSnapshot provides a mock function with given fields: table, shard, redoLogFile, offset
func (_m *DiskStore) DeleteSnapshot(table string, shard int, redoLogFile int64, offset uint32) error {
	ret := _m.Called(table, shard, redoLogFile, offset)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int, int64, uint32) error); ok {
		r0 = rf(table, shard, redoLogFile, offset)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTableShard provides a mock function with given fields: table, shard
func (_m *DiskStore) DeleteTableShard(table string, shard int) error {
	ret := _m.Called(table, shard)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int) error); ok {
		r0 = rf(table, shard)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListLogFiles provides a mock function with given fields: table, shard
func (_m *DiskStore) ListLogFiles(table string, shard int) ([]int64, error) {
	ret := _m.Called(table, shard)

	var r0 []int64
	if rf, ok := ret.Get(0).(func(string, int) []int64); ok {
		r0 = rf(table, shard)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int) error); ok {
		r1 = rf(table, shard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSnapshotBatches provides a mock function with given fields: table, shard, redoLogFile, offset
func (_m *DiskStore) ListSnapshotBatches(table string, shard int, redoLogFile int64, offset uint32) ([]int, error) {
	ret := _m.Called(table, shard, redoLogFile, offset)

	var r0 []int
	if rf, ok := ret.Get(0).(func(string, int, int64, uint32) []int); ok {
		r0 = rf(table, shard, redoLogFile, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int64, uint32) error); ok {
		r1 = rf(table, shard, redoLogFile, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSnapshotVectorPartyFiles provides a mock function with given fields: table, shard, redoLogFile, offset, batchID
func (_m *DiskStore) ListSnapshotVectorPartyFiles(table string, shard int, redoLogFile int64, offset uint32, batchID int) ([]int, error) {
	ret := _m.Called(table, shard, redoLogFile, offset, batchID)

	var r0 []int
	if rf, ok := ret.Get(0).(func(string, int, int64, uint32, int) []int); ok {
		r0 = rf(table, shard, redoLogFile, offset, batchID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int64, uint32, int) error); ok {
		r1 = rf(table, shard, redoLogFile, offset, batchID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenLogFileForAppend provides a mock function with given fields: table, shard, creationTime
func (_m *DiskStore) OpenLogFileForAppend(table string, shard int, creationTime int64) (io.WriteCloser, error) {
	ret := _m.Called(table, shard, creationTime)

	var r0 io.WriteCloser
	if rf, ok := ret.Get(0).(func(string, int, int64) io.WriteCloser); ok {
		r0 = rf(table, shard, creationTime)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.WriteCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int64) error); ok {
		r1 = rf(table, shard, creationTime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenLogFileForReplay provides a mock function with given fields: table, shard, creationTime
func (_m *DiskStore) OpenLogFileForReplay(table string, shard int, creationTime int64) (utils.ReaderSeekerCloser, error) {
	ret := _m.Called(table, shard, creationTime)

	var r0 utils.ReaderSeekerCloser
	if rf, ok := ret.Get(0).(func(string, int, int64) utils.ReaderSeekerCloser); ok {
		r0 = rf(table, shard, creationTime)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(utils.ReaderSeekerCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int64) error); ok {
		r1 = rf(table, shard, creationTime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenSnapshotVectorPartyFileForAppend provides a mock function with given fields: table, shard, redoLogFile, offset, batchID, columnID
func (_m *DiskStore) OpenSnapshotVectorPartyFileForAppend(table string, shard int, redoLogFile int64, offset uint32, batchID int, columnID int) (io.WriteCloser, error) {
	ret := _m.Called(table, shard, redoLogFile, offset, batchID, columnID)

	var r0 io.WriteCloser
	if rf, ok := ret.Get(0).(func(string, int, int64, uint32, int, int) io.WriteCloser); ok {
		r0 = rf(table, shard, redoLogFile, offset, batchID, columnID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.WriteCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int64, uint32, int, int) error); ok {
		r1 = rf(table, shard, redoLogFile, offset, batchID, columnID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenSnapshotVectorPartyFileForRead provides a mock function with given fields: table, shard, redoLogFile, offset, batchID, columnID
func (_m *DiskStore) OpenSnapshotVectorPartyFileForRead(table string, shard int, redoLogFile int64, offset uint32, batchID int, columnID int) (io.ReadCloser, error) {
	ret := _m.Called(table, shard, redoLogFile, offset, batchID, columnID)

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func(string, int, int64, uint32, int, int) io.ReadCloser); ok {
		r0 = rf(table, shard, redoLogFile, offset, batchID, columnID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int64, uint32, int, int) error); ok {
		r1 = rf(table, shard, redoLogFile, offset, batchID, columnID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenSnapshotVectorPartyFileForWrite provides a mock function with given fields: table, shard, redoLogFile, offset, batchID, columnID
func (_m *DiskStore) OpenSnapshotVectorPartyFileForWrite(table string, shard int, redoLogFile int64, offset uint32, batchID int, columnID int) (io.WriteCloser, error) {
	ret := _m.Called(table, shard, redoLogFile, offset, batchID, columnID)

	var r0 io.WriteCloser
	if rf, ok := ret.Get(0).(func(string, int, int64, uint32, int, int) io.WriteCloser); ok {
		r0 = rf(table, shard, redoLogFile, offset, batchID, columnID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.WriteCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int64, uint32, int, int) error); ok {
		r1 = rf(table, shard, redoLogFile, offset, batchID, columnID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenVectorPartyFileForAppend provides a mock function with given fields: table, column, shard, batchID, batchVersion, seqNum
func (_m *DiskStore) OpenVectorPartyFileForAppend(table string, column int, shard int, batchID int, batchVersion uint32, seqNum uint32) (io.WriteCloser, error) {
	ret := _m.Called(table, column, shard, batchID, batchVersion, seqNum)

	var r0 io.WriteCloser
	if rf, ok := ret.Get(0).(func(string, int, int, int, uint32, uint32) io.WriteCloser); ok {
		r0 = rf(table, column, shard, batchID, batchVersion, seqNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.WriteCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int, int, uint32, uint32) error); ok {
		r1 = rf(table, column, shard, batchID, batchVersion, seqNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenVectorPartyFileForRead provides a mock function with given fields: table, column, shard, batchID, batchVersion, seqNum
func (_m *DiskStore) OpenVectorPartyFileForRead(table string, column int, shard int, batchID int, batchVersion uint32, seqNum uint32) (io.ReadCloser, error) {
	ret := _m.Called(table, column, shard, batchID, batchVersion, seqNum)

	var r0 io.ReadCloser
	if rf, ok := ret.Get(0).(func(string, int, int, int, uint32, uint32) io.ReadCloser); ok {
		r0 = rf(table, column, shard, batchID, batchVersion, seqNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int, int, uint32, uint32) error); ok {
		r1 = rf(table, column, shard, batchID, batchVersion, seqNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenVectorPartyFileForWrite provides a mock function with given fields: table, column, shard, batchID, batchVersion, seqNum
func (_m *DiskStore) OpenVectorPartyFileForWrite(table string, column int, shard int, batchID int, batchVersion uint32, seqNum uint32) (io.WriteCloser, error) {
	ret := _m.Called(table, column, shard, batchID, batchVersion, seqNum)

	var r0 io.WriteCloser
	if rf, ok := ret.Get(0).(func(string, int, int, int, uint32, uint32) io.WriteCloser); ok {
		r0 = rf(table, column, shard, batchID, batchVersion, seqNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.WriteCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int, int, uint32, uint32) error); ok {
		r1 = rf(table, column, shard, batchID, batchVersion, seqNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TruncateLogFile provides a mock function with given fields: table, shard, creationTime, offset
func (_m *DiskStore) TruncateLogFile(table string, shard int, creationTime int64, offset int64) error {
	ret := _m.Called(table, shard, creationTime, offset)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int, int64, int64) error); ok {
		r0 = rf(table, shard, creationTime, offset)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
